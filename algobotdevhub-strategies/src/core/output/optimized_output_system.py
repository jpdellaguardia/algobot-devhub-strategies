# src/core/output/optimized_output_system.py
"""
Optimized Output System for Backtesting Framework.

This module implements an optimized output structure with:
1. Elimination of redundant JSON files for strategy/risk trades (keeping only CSV)
2. Reorganized hierarchy with analysis reports at top level
3. Organized visualization folders (portfolio vs individual)
4. Transaction cost analysis integration
5. Clear structure: Analysis → Visualizations → Data → Individual Tickers
"""

import logging
import pandas as pd
from pathlib import Path
from typing import Dict, List, Any, Optional, Union
from datetime import datetime
import json
import shutil

class OptimizedOutputSystem:
    """
    Manages optimized output structure for comprehensive analysis.
    """
    
    def __init__(self, strategy_run_dir: Path):
        """
        Initialize the optimized output system.
        
        Args:
            strategy_run_dir: Path to strategy run directory
        """
        self.strategy_run_dir = strategy_run_dir
        self.logger = logging.getLogger("OptimizedOutputSystem")
        
        # Create optimized directory structure
        self._create_optimized_directories()
        
    def _create_optimized_directories(self):
        """Create optimized directory structure."""
        directories = [
            # Top-level analysis
            'analysis_reports',
            'analysis_reports/portfolio',
            'analysis_reports/individual',
            
            # Organized visualizations
            'visualizations',
            'visualizations/portfolio',
            'visualizations/individual',
            
            # Data files (CSV only for trades)
            'data',
            'data/base_data',      # CSV + JSON metadata (rich data needs metadata)
            'data/strategy_trades',  # CSV only (redundant JSON removed)
            'data/risk_approved_trades',  # CSV only (redundant JSON removed)
            
            # Individual ticker details
            'tickers',
            
            # Reports and summaries
            'reports',
            'reports/transaction_costs',
            'reports/executive_summary'
        ]
        
        for directory in directories:
            (self.strategy_run_dir / directory).mkdir(parents=True, exist_ok=True)
    
    def save_base_data_file(self, ticker: str, date_range: str, base_data: pd.DataFrame) -> Path:
        """
        Save base data with metadata (keeps JSON for rich data).
        
        Args:
            ticker: Ticker symbol
            date_range: Date range string
            base_data: DataFrame with price data, signals, and indicators
            
        Returns:
            Path to saved base file
        """
        file_path = self.strategy_run_dir / 'data' / 'base_data' / f"{ticker}_Base_{date_range}.csv"
        
        # Ensure required columns are present
        required_columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume', 'ticker']
        
        for col in required_columns:
            if col not in base_data.columns:
                if col == 'ticker':
                    base_data[col] = ticker
                else:
                    base_data[col] = 0
        
        # Save CSV data
        base_data.to_csv(file_path, index=False)
        
        # Create comprehensive metadata (keep for rich base data)
        metadata = {
            'file_type': 'base_data',
            'ticker': ticker,
            'date_range': date_range,
            'total_rows': len(base_data),
            'columns': list(base_data.columns),
            'created_at': datetime.now().isoformat(),
            'data_summary': {
                'date_start': str(base_data['timestamp'].min()) if 'timestamp' in base_data.columns else 'N/A',
                'date_end': str(base_data['timestamp'].max()) if 'timestamp' in base_data.columns else 'N/A',
                'signal_counts': self._count_signals(base_data)
            }
        }
        
        # Save metadata
        metadata_path = file_path.with_suffix('.json')
        with open(metadata_path, 'w') as f:
            json.dump(metadata, f, indent=2, default=str)
        
        self.logger.info(f"Saved base data for {ticker}: {file_path}")
        return file_path
    
    def save_strategy_trades_file(self, ticker: str, date_range: str, 
                                  all_trades: List[Dict], 
                                  strategy_metadata: Dict[str, Any]) -> Path:
        """
        Save strategy trades (CSV only - no redundant JSON).
        
        Args:
            ticker: Ticker symbol
            date_range: Date range string
            all_trades: List of all trades generated by strategy
            strategy_metadata: Metadata about strategy execution
            
        Returns:
            Path to saved strategy trades file
        """
        file_path = self.strategy_run_dir / 'data' / 'strategy_trades' / f"{ticker}_StrategyTrades_{date_range}.csv"
        
        # Prepare trades DataFrame
        if all_trades:
            trades_df = pd.DataFrame(all_trades)
        else:
            trades_df = self._create_empty_trades_df()
        
        # Add essential metadata columns
        trades_df['ticker'] = ticker
        trades_df['strategy_generated'] = True
        trades_df['risk_processed'] = False
        
        # Add transaction cost analysis
        trades_df = self._add_transaction_cost_analysis(trades_df)
        
        # Save CSV only (eliminate redundant JSON)
        trades_df.to_csv(file_path, index=False)
        
        self.logger.info(f"Saved strategy trades for {ticker}: {len(all_trades)} trades (CSV only)")
        return file_path
    
    def save_risk_approved_trades_file(self, ticker: str, date_range: str,
                                       approved_trades: List[Dict],
                                       risk_analysis: Dict[str, Any]) -> Path:
        """
        Save risk-approved trades (CSV only - no redundant JSON).
        
        Args:
            ticker: Ticker symbol
            date_range: Date range string
            approved_trades: List of trades that passed risk management
            risk_analysis: Risk management analysis results
            
        Returns:
            Path to saved risk-approved trades file
        """
        file_path = self.strategy_run_dir / 'data' / 'risk_approved_trades' / f"{ticker}_RiskApprovedTrades_{date_range}.csv"
        
        # Prepare trades DataFrame
        if approved_trades:
            trades_df = pd.DataFrame(approved_trades)
        else:
            trades_df = self._create_empty_trades_df()
        
        # Add essential metadata columns
        trades_df['ticker'] = ticker
        trades_df['strategy_generated'] = True
        trades_df['risk_processed'] = True
        trades_df['risk_approved'] = True
        
        # Add transaction cost analysis
        trades_df = self._add_transaction_cost_analysis(trades_df)
        
        # Save CSV only (eliminate redundant JSON)
        trades_df.to_csv(file_path, index=False)
        
        self.logger.info(f"Saved risk-approved trades for {ticker}: {len(approved_trades)} trades (CSV only)")
        return file_path
    
    def _add_transaction_cost_analysis(self, trades_df: pd.DataFrame) -> pd.DataFrame:
        """
        Add transaction cost analysis to trades DataFrame.
        
        Args:
            trades_df: DataFrame with trade data
            
        Returns:
            DataFrame with transaction cost columns added
        """
        if trades_df.empty:
            return trades_df
        
        # Default transaction cost assumptions (can be configured)
        BROKERAGE_RATE = 0.0003  # 0.03%
        STT_RATE = 0.001         # 0.1% 
        EXCHANGE_CHARGES = 0.0000345  # 0.00345%
        GST_RATE = 0.18          # 18% on brokerage + exchange charges
        
        # Calculate transaction costs if price columns exist
        if 'Entry Price' in trades_df.columns and 'Exit Price' in trades_df.columns:
            # Entry costs
            entry_value = trades_df['Entry Price'] * trades_df.get('Quantity', 100)
            entry_brokerage = entry_value * BROKERAGE_RATE
            entry_stt = entry_value * STT_RATE
            entry_exchange = entry_value * EXCHANGE_CHARGES
            entry_gst = (entry_brokerage + entry_exchange) * GST_RATE
            entry_total_cost = entry_brokerage + entry_stt + entry_exchange + entry_gst
            
            # Exit costs
            exit_value = trades_df['Exit Price'] * trades_df.get('Quantity', 100)
            exit_brokerage = exit_value * BROKERAGE_RATE
            exit_stt = exit_value * STT_RATE
            exit_exchange = exit_value * EXCHANGE_CHARGES
            exit_gst = (exit_brokerage + exit_exchange) * GST_RATE
            exit_total_cost = exit_brokerage + exit_stt + exit_exchange + exit_gst
            
            # Total transaction costs
            total_transaction_cost = entry_total_cost + exit_total_cost
            
            # Add transaction cost columns
            trades_df['Entry_Transaction_Cost'] = entry_total_cost
            trades_df['Exit_Transaction_Cost'] = exit_total_cost
            trades_df['Total_Transaction_Cost'] = total_transaction_cost
            trades_df['Transaction_Cost_Pct'] = (total_transaction_cost / entry_value) * 100
            
            # Net profit after transaction costs
            if 'Profit (Currency)' in trades_df.columns:
                trades_df['Net_Profit_After_Costs'] = trades_df['Profit (Currency)'] - total_transaction_cost
                trades_df['Net_Profit_Pct_After_Costs'] = (trades_df['Net_Profit_After_Costs'] / entry_value) * 100
        
        return trades_df
    
    def create_comprehensive_analysis(self, ticker: str, date_range: str) -> Dict[str, Path]:
        """
        Create comprehensive analysis with optimized structure.
        
        Args:
            ticker: Ticker symbol
            date_range: Date range string
            
        Returns:
            Dictionary of created analysis files
        """
        analysis_files = {}
        
        # Load data files
        base_file = self.strategy_run_dir / 'data' / 'base_data' / f"{ticker}_Base_{date_range}.csv"
        strategy_trades_file = self.strategy_run_dir / 'data' / 'strategy_trades' / f"{ticker}_StrategyTrades_{date_range}.csv"
        risk_trades_file = self.strategy_run_dir / 'data' / 'risk_approved_trades' / f"{ticker}_RiskApprovedTrades_{date_range}.csv"
        
        try:
            # Load data
            base_data = pd.read_csv(base_file) if base_file.exists() else pd.DataFrame()
            strategy_trades = pd.read_csv(strategy_trades_file) if strategy_trades_file.exists() else pd.DataFrame()
            risk_trades = pd.read_csv(risk_trades_file) if risk_trades_file.exists() else pd.DataFrame()
            
            # Create comprehensive analysis
            analysis = {
                'ticker': ticker,
                'date_range': date_range,
                'analysis_timestamp': datetime.now().isoformat(),
                'data_summary': {
                    'base_data_points': len(base_data),
                    'strategy_trades_generated': len(strategy_trades),
                    'risk_approved_trades': len(risk_trades),
                    'risk_rejection_count': len(strategy_trades) - len(risk_trades),
                    'risk_approval_rate': len(risk_trades) / len(strategy_trades) if len(strategy_trades) > 0 else 0
                },
                'signal_analysis': self._analyze_signals(base_data),
                'strategy_performance': self._analyze_strategy_trades(strategy_trades),
                'risk_impact': self._analyze_risk_impact(strategy_trades, risk_trades),
                'transaction_cost_analysis': self._analyze_transaction_costs(strategy_trades, risk_trades),
                'recommendations': self._generate_recommendations(base_data, strategy_trades, risk_trades)
            }
            
            # Save to individual analysis folder
            analysis_file = self.strategy_run_dir / 'analysis_reports' / 'individual' / f"{ticker}_Analysis_{date_range}.json"
            with open(analysis_file, 'w') as f:
                json.dump(analysis, f, indent=2, default=str)
            
            analysis_files['individual_analysis'] = analysis_file
            
            # Create transaction cost report
            cost_report_file = self._create_transaction_cost_report(ticker, date_range, analysis['transaction_cost_analysis'])
            analysis_files['transaction_cost_report'] = cost_report_file
            
        except Exception as e:
            self.logger.error(f"Error creating analysis for {ticker}: {e}")
        
        return analysis_files
    
    def _analyze_transaction_costs(self, strategy_trades: pd.DataFrame, risk_trades: pd.DataFrame) -> Dict[str, Any]:
        """
        Analyze transaction cost impact on trading performance.
        
        Args:
            strategy_trades: DataFrame with strategy trades
            risk_trades: DataFrame with risk-approved trades
            
        Returns:
            Transaction cost analysis results
        """
        analysis = {
            'strategy_trades_cost_analysis': {},
            'risk_approved_trades_cost_analysis': {},
            'cost_efficiency_metrics': {},
            'cost_optimization_recommendations': []
        }
        
        # Analyze strategy trades costs
        if not strategy_trades.empty and 'Total_Transaction_Cost' in strategy_trades.columns:
            total_cost = strategy_trades['Total_Transaction_Cost'].sum()
            avg_cost_per_trade = strategy_trades['Total_Transaction_Cost'].mean()
            avg_cost_pct = strategy_trades['Transaction_Cost_Pct'].mean()
            
            analysis['strategy_trades_cost_analysis'] = {
                'total_trades': len(strategy_trades),
                'total_transaction_cost': float(total_cost),
                'avg_cost_per_trade': float(avg_cost_per_trade),
                'avg_cost_percentage': float(avg_cost_pct),
                'cost_range': {
                    'min_cost': float(strategy_trades['Total_Transaction_Cost'].min()),
                    'max_cost': float(strategy_trades['Total_Transaction_Cost'].max())
                }
            }
            
            # Net profit analysis
            if 'Net_Profit_After_Costs' in strategy_trades.columns:
                gross_profit = strategy_trades['Profit (Currency)'].sum() if 'Profit (Currency)' in strategy_trades.columns else 0
                net_profit = strategy_trades['Net_Profit_After_Costs'].sum()
                cost_impact = gross_profit - net_profit
                
                analysis['strategy_trades_cost_analysis']['profit_impact'] = {
                    'gross_profit': float(gross_profit),
                    'net_profit_after_costs': float(net_profit),
                    'cost_impact_amount': float(cost_impact),
                    'cost_impact_percentage': float((cost_impact / gross_profit * 100) if gross_profit != 0 else 0)
                }
        
        # Analyze risk-approved trades costs
        if not risk_trades.empty and 'Total_Transaction_Cost' in risk_trades.columns:
            total_cost = risk_trades['Total_Transaction_Cost'].sum()
            avg_cost_per_trade = risk_trades['Total_Transaction_Cost'].mean()
            avg_cost_pct = risk_trades['Transaction_Cost_Pct'].mean()
            
            analysis['risk_approved_trades_cost_analysis'] = {
                'total_trades': len(risk_trades),
                'total_transaction_cost': float(total_cost),
                'avg_cost_per_trade': float(avg_cost_per_trade),
                'avg_cost_percentage': float(avg_cost_pct),
                'cost_range': {
                    'min_cost': float(risk_trades['Total_Transaction_Cost'].min()),
                    'max_cost': float(risk_trades['Total_Transaction_Cost'].max())
                }
            }
            
            # Net profit analysis
            if 'Net_Profit_After_Costs' in risk_trades.columns:
                gross_profit = risk_trades['Profit (Currency)'].sum() if 'Profit (Currency)' in risk_trades.columns else 0
                net_profit = risk_trades['Net_Profit_After_Costs'].sum()
                cost_impact = gross_profit - net_profit
                
                analysis['risk_approved_trades_cost_analysis']['profit_impact'] = {
                    'gross_profit': float(gross_profit),
                    'net_profit_after_costs': float(net_profit),
                    'cost_impact_amount': float(cost_impact),
                    'cost_impact_percentage': float((cost_impact / gross_profit * 100) if gross_profit != 0 else 0)
                }
        
        # Cost efficiency metrics
        if (not strategy_trades.empty and not risk_trades.empty and 
            'Total_Transaction_Cost' in strategy_trades.columns and 
            'Total_Transaction_Cost' in risk_trades.columns):
            
            strategy_total_cost = strategy_trades['Total_Transaction_Cost'].sum()
            risk_total_cost = risk_trades['Total_Transaction_Cost'].sum()
            cost_saved_by_risk_filtering = strategy_total_cost - risk_total_cost
            
            analysis['cost_efficiency_metrics'] = {
                'cost_saved_by_risk_filtering': float(cost_saved_by_risk_filtering),
                'cost_savings_percentage': float((cost_saved_by_risk_filtering / strategy_total_cost * 100) if strategy_total_cost > 0 else 0),
                'risk_filtering_cost_efficiency': 'High' if cost_saved_by_risk_filtering > strategy_total_cost * 0.3 else 'Medium' if cost_saved_by_risk_filtering > 0 else 'Low'
            }
        
        # Generate cost optimization recommendations
        analysis['cost_optimization_recommendations'] = self._generate_cost_recommendations(analysis)
        
        return analysis
    
    def _generate_cost_recommendations(self, cost_analysis: Dict[str, Any]) -> List[str]:
        """Generate cost optimization recommendations."""
        recommendations = []
        
        # Check average cost percentage
        strategy_cost_pct = cost_analysis.get('strategy_trades_cost_analysis', {}).get('avg_cost_percentage', 0)
        if strategy_cost_pct > 1.0:  # More than 1%
            recommendations.append("High transaction costs detected - consider optimizing trade frequency or size")
        
        # Check cost impact on profits
        strategy_profit_impact = cost_analysis.get('strategy_trades_cost_analysis', {}).get('profit_impact', {})
        cost_impact_pct = strategy_profit_impact.get('cost_impact_percentage', 0)
        
        if cost_impact_pct > 20:
            recommendations.append("Transaction costs significantly impact profits - review trading strategy")
        elif cost_impact_pct > 10:
            recommendations.append("Moderate transaction cost impact - consider trade optimization")
        
        # Check risk filtering efficiency
        cost_efficiency = cost_analysis.get('cost_efficiency_metrics', {}).get('risk_filtering_cost_efficiency', 'Low')
        if cost_efficiency == 'High':        recommendations.append("Risk filtering provides excellent cost savings - maintain current parameters")
        elif cost_efficiency == 'Low':
            recommendations.append("Limited cost savings from risk filtering - review risk parameters")
        
        return recommendations
    
    def _create_transaction_cost_report(self, ticker: str, date_range: str, cost_analysis: Dict[str, Any]) -> Path:
        """Create detailed transaction cost report."""
        report_file = self.strategy_run_dir / 'reports' / 'transaction_costs' / f"{ticker}_TransactionCostReport_{date_range}.txt"
        
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(f"Transaction Cost Analysis Report\n")
            f.write(f"=" * 50 + "\n\n")
            f.write(f"Ticker: {ticker}\n")
            f.write(f"Date Range: {date_range}\n")
            f.write(f"Analysis Time: {datetime.now().isoformat()}\n\n")
            
            # Strategy trades cost analysis
            strategy_analysis = cost_analysis.get('strategy_trades_cost_analysis', {})
            if strategy_analysis:
                f.write(f"Strategy Trades Cost Analysis:\n")
                f.write(f"- Total trades: {strategy_analysis.get('total_trades', 0)}\n")
                f.write(f"- Total transaction cost: ₹{strategy_analysis.get('total_transaction_cost', 0):,.2f}\n")
                f.write(f"- Average cost per trade: ₹{strategy_analysis.get('avg_cost_per_trade', 0):.2f}\n")
                f.write(f"- Average cost percentage: {strategy_analysis.get('avg_cost_percentage', 0):.3f}%\n\n")
                
                profit_impact = strategy_analysis.get('profit_impact', {})
                if profit_impact:
                    f.write(f"Profit Impact:\n")
                    f.write(f"- Gross profit: ₹{profit_impact.get('gross_profit', 0):,.2f}\n")
                    f.write(f"- Net profit after costs: ₹{profit_impact.get('net_profit_after_costs', 0):,.2f}\n")
                    f.write(f"- Cost impact: ₹{profit_impact.get('cost_impact_amount', 0):,.2f} ({profit_impact.get('cost_impact_percentage', 0):.1f}%)\n\n")
            
            # Risk-approved trades cost analysis
            risk_analysis = cost_analysis.get('risk_approved_trades_cost_analysis', {})
            if risk_analysis:
                f.write(f"Risk-Approved Trades Cost Analysis:\n")
                f.write(f"- Total trades: {risk_analysis.get('total_trades', 0)}\n")
                f.write(f"- Total transaction cost: ₹{risk_analysis.get('total_transaction_cost', 0):,.2f}\n")
                f.write(f"- Average cost per trade: ₹{risk_analysis.get('avg_cost_per_trade', 0):.2f}\n")
                f.write(f"- Average cost percentage: {risk_analysis.get('avg_cost_percentage', 0):.3f}%\n\n")
            
            # Cost efficiency metrics
            efficiency_metrics = cost_analysis.get('cost_efficiency_metrics', {})
            if efficiency_metrics:
                f.write(f"Cost Efficiency Metrics:\n")
                f.write(f"- Cost saved by risk filtering: ₹{efficiency_metrics.get('cost_saved_by_risk_filtering', 0):,.2f}\n")
                f.write(f"- Cost savings percentage: {efficiency_metrics.get('cost_savings_percentage', 0):.1f}%\n")
                f.write(f"- Risk filtering efficiency: {efficiency_metrics.get('risk_filtering_cost_efficiency', 'N/A')}\n\n")
            
            # Recommendations
            recommendations = cost_analysis.get('cost_optimization_recommendations', [])
            if recommendations:
                f.write(f"Cost Optimization Recommendations:\n")
                for i, rec in enumerate(recommendations, 1):
                    f.write(f"{i}. {rec}\n")
        
        return report_file
    
    def create_portfolio_analysis(self, date_range: str, tickers: List[str]) -> Dict[str, Any]:
        """
        Create portfolio-level analysis with optimized structure.
        
        Args:
            date_range: Date range string
            tickers: List of tickers to analyze
            
        Returns:
            Portfolio analysis results
        """
        portfolio_analysis = {
            'analysis_type': 'portfolio_comprehensive_analysis',
            'date_range': date_range,
            'tickers': tickers,
            'analysis_timestamp': datetime.now().isoformat(),
            'portfolio_summary': {},
            'ticker_breakdowns': {},
            'portfolio_transaction_cost_analysis': {},
            'cross_ticker_analysis': {}
        }
        
        # Aggregate data across all tickers
        total_base_points = 0
        total_strategy_trades = 0
        total_risk_approved = 0
        total_transaction_costs = 0
        
        for ticker in tickers:
            try:
                # Load individual analysis
                analysis_file = self.strategy_run_dir / 'analysis_reports' / 'individual' / f"{ticker}_Analysis_{date_range}.json"
                if analysis_file.exists():
                    with open(analysis_file, 'r') as f:
                        ticker_analysis = json.load(f)
                    
                    portfolio_analysis['ticker_breakdowns'][ticker] = ticker_analysis
                    
                    # Aggregate numbers
                    data_summary = ticker_analysis.get('data_summary', {})
                    total_base_points += data_summary.get('base_data_points', 0)
                    total_strategy_trades += data_summary.get('strategy_trades_generated', 0)
                    total_risk_approved += data_summary.get('risk_approved_trades', 0)
                    
                    # Aggregate transaction costs
                    cost_analysis = ticker_analysis.get('transaction_cost_analysis', {})
                    strategy_cost = cost_analysis.get('strategy_trades_cost_analysis', {}).get('total_transaction_cost', 0)
                    total_transaction_costs += strategy_cost
                    
            except Exception as e:
                self.logger.error(f"Error loading analysis for {ticker}: {e}")
        
        # Portfolio summary
        portfolio_analysis['portfolio_summary'] = {
            'total_tickers': len(tickers),
            'total_base_data_points': total_base_points,
            'total_strategy_trades': total_strategy_trades,
            'total_risk_approved_trades': total_risk_approved,
            'portfolio_approval_rate': total_risk_approved / total_strategy_trades if total_strategy_trades > 0 else 0,
            'avg_trades_per_ticker': total_strategy_trades / len(tickers) if tickers else 0,
            'total_portfolio_transaction_costs': total_transaction_costs
        }
        
        # Portfolio transaction cost analysis
        portfolio_analysis['portfolio_transaction_cost_analysis'] = self._analyze_portfolio_transaction_costs(tickers, date_range)
        
        # Cross-ticker analysis
        if portfolio_analysis['ticker_breakdowns']:
            portfolio_analysis['cross_ticker_analysis'] = {
                'most_active_ticker': max(portfolio_analysis['ticker_breakdowns'].items(), 
                                        key=lambda x: x[1].get('data_summary', {}).get('strategy_trades_generated', 0))[0],
                'highest_approval_rate_ticker': max(portfolio_analysis['ticker_breakdowns'].items(),
                                                  key=lambda x: x[1].get('data_summary', {}).get('risk_approval_rate', 0))[0],
                'highest_cost_ticker': max(portfolio_analysis['ticker_breakdowns'].items(),
                                         key=lambda x: x[1].get('transaction_cost_analysis', {}).get('strategy_trades_cost_analysis', {}).get('total_transaction_cost', 0))[0]
            }
        
        # Save portfolio analysis
        portfolio_file = self.strategy_run_dir / 'analysis_reports' / 'portfolio' / f"Portfolio_Analysis_{date_range}.json"
        with open(portfolio_file, 'w') as f:
            json.dump(portfolio_analysis, f, indent=2, default=str)
        
        # Create portfolio transaction cost report
        self._create_portfolio_cost_report(date_range, portfolio_analysis['portfolio_transaction_cost_analysis'])
        
        self.logger.info(f"Created optimized portfolio analysis for {len(tickers)} tickers")
        return portfolio_analysis
    
    def _analyze_portfolio_transaction_costs(self, tickers: List[str], date_range: str) -> Dict[str, Any]:
        """Analyze transaction costs across the entire portfolio."""
        portfolio_cost_analysis = {
            'total_portfolio_cost': 0,
            'cost_breakdown_by_ticker': {},
            'cost_efficiency_ranking': [],
            'portfolio_cost_recommendations': []
        }
        
        ticker_costs = []
        
        for ticker in tickers:
            try:
                analysis_file = self.strategy_run_dir / 'analysis_reports' / 'individual' / f"{ticker}_Analysis_{date_range}.json"
                if analysis_file.exists():
                    with open(analysis_file, 'r') as f:
                        ticker_analysis = json.load(f)
                    
                    cost_analysis = ticker_analysis.get('transaction_cost_analysis', {})
                    strategy_cost_analysis = cost_analysis.get('strategy_trades_cost_analysis', {})
                    
                    if strategy_cost_analysis:
                        ticker_cost = strategy_cost_analysis.get('total_transaction_cost', 0)
                        ticker_trades = strategy_cost_analysis.get('total_trades', 0)
                        
                        portfolio_cost_analysis['cost_breakdown_by_ticker'][ticker] = {
                            'total_cost': ticker_cost,
                            'total_trades': ticker_trades,
                            'avg_cost_per_trade': ticker_cost / ticker_trades if ticker_trades > 0 else 0,
                            'cost_percentage_of_portfolio': 0  # Will be calculated after total
                        }
                        
                        ticker_costs.append((ticker, ticker_cost, ticker_trades))
                        portfolio_cost_analysis['total_portfolio_cost'] += ticker_cost
                        
            except Exception as e:
                self.logger.error(f"Error analyzing costs for {ticker}: {e}")
        
        # Calculate cost percentages and rankings
        if portfolio_cost_analysis['total_portfolio_cost'] > 0:
            for ticker in portfolio_cost_analysis['cost_breakdown_by_ticker']:
                ticker_cost = portfolio_cost_analysis['cost_breakdown_by_ticker'][ticker]['total_cost']
                portfolio_cost_analysis['cost_breakdown_by_ticker'][ticker]['cost_percentage_of_portfolio'] = (
                    ticker_cost / portfolio_cost_analysis['total_portfolio_cost'] * 100
                )
            
            # Cost efficiency ranking (lower cost per trade is better)
            portfolio_cost_analysis['cost_efficiency_ranking'] = sorted(
                ticker_costs,
                key=lambda x: x[1] / x[2] if x[2] > 0 else float('inf')  # cost per trade
            )
        
        # Generate portfolio cost recommendations
        portfolio_cost_analysis['portfolio_cost_recommendations'] = self._generate_portfolio_cost_recommendations(
            portfolio_cost_analysis
        )
        
        return portfolio_cost_analysis
    
    def _generate_portfolio_cost_recommendations(self, portfolio_cost_analysis: Dict[str, Any]) -> List[str]:
        """Generate portfolio-level cost optimization recommendations."""
        recommendations = []
        
        # Check cost distribution
        cost_breakdown = portfolio_cost_analysis.get('cost_breakdown_by_ticker', {})
        if cost_breakdown:
            # Find highest cost ticker
            highest_cost_ticker = max(cost_breakdown.items(), key=lambda x: x[1]['total_cost'])
            highest_cost_pct = highest_cost_ticker[1]['cost_percentage_of_portfolio']
            
            if highest_cost_pct > 50:
                recommendations.append(f"High cost concentration in {highest_cost_ticker[0]} ({highest_cost_pct:.1f}%) - review trading frequency")
            
            # Check cost efficiency
            efficiency_ranking = portfolio_cost_analysis.get('cost_efficiency_ranking', [])
            if len(efficiency_ranking) >= 2:
                most_efficient = efficiency_ranking[0]
                least_efficient = efficiency_ranking[-1]
                
                if len(efficiency_ranking) > 1:
                    efficiency_gap = (least_efficient[1] / least_efficient[2]) - (most_efficient[1] / most_efficient[2])
                    if efficiency_gap > 100:  # Rs. 100 difference in cost per trade
                        recommendations.append(f"Large cost efficiency gap between {most_efficient[0]} and {least_efficient[0]} - consider optimizing {least_efficient[0]} strategy")
        
        total_cost = portfolio_cost_analysis.get('total_portfolio_cost', 0)
        if total_cost > 10000:  # Rs. 10,000
            recommendations.append("High total portfolio transaction costs - consider batch trading or position sizing optimization")
        
        return recommendations
    
    def _create_portfolio_cost_report(self, date_range: str, portfolio_cost_analysis: Dict[str, Any]) -> Path:
        """Create portfolio-level transaction cost report."""
        report_file = self.strategy_run_dir / 'reports' / 'transaction_costs' / f"Portfolio_TransactionCostReport_{date_range}.txt"
        
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(f"Portfolio Transaction Cost Analysis Report\n")
            f.write(f"=" * 60 + "\n\n")
            f.write(f"Date Range: {date_range}\n")
            f.write(f"Analysis Time: {datetime.now().isoformat()}\n\n")
            
            # Portfolio summary
            f.write(f"Portfolio Cost Summary:\n")
            f.write(f"- Total portfolio transaction cost: ₹{portfolio_cost_analysis.get('total_portfolio_cost', 0):,.2f}\n\n")
            
            # Cost breakdown by ticker
            cost_breakdown = portfolio_cost_analysis.get('cost_breakdown_by_ticker', {})
            if cost_breakdown:
                f.write(f"Cost Breakdown by Ticker:\n")
                for ticker, cost_data in cost_breakdown.items():
                    f.write(f"  {ticker}:\n")
                    f.write(f"    - Total cost: ₹{cost_data['total_cost']:,.2f} ({cost_data['cost_percentage_of_portfolio']:.1f}% of portfolio)\n")
                    f.write(f"    - Total trades: {cost_data['total_trades']}\n")
                    f.write(f"    - Avg cost per trade: ₹{cost_data['avg_cost_per_trade']:.2f}\n\n")
            
            # Cost efficiency ranking
            efficiency_ranking = portfolio_cost_analysis.get('cost_efficiency_ranking', [])
            if efficiency_ranking:
                f.write(f"Cost Efficiency Ranking (Best to Worst):\n")
                for i, (ticker, total_cost, trades) in enumerate(efficiency_ranking, 1):
                    cost_per_trade = total_cost / trades if trades > 0 else 0
                    f.write(f"  {i}. {ticker}: ₹{cost_per_trade:.2f} per trade\n")
                f.write("\n")
            
            # Recommendations
            recommendations = portfolio_cost_analysis.get('portfolio_cost_recommendations', [])
            if recommendations:
                f.write(f"Portfolio Cost Optimization Recommendations:\n")
                for i, rec in enumerate(recommendations, 1):
                    f.write(f"{i}. {rec}\n")
        
        return report_file
    
    def organize_visualizations(self, visualization_files: Dict[str, Path]) -> Dict[str, Path]:
        """
        Organize visualization files into portfolio and individual folders.
        
        Args:
            visualization_files: Dictionary mapping visualization types to file paths
            
        Returns:
            Dictionary of organized visualization paths
        """
        organized_files = {}
        
        portfolio_viz_dir = self.strategy_run_dir / 'visualizations' / 'portfolio'
        individual_viz_dir = self.strategy_run_dir / 'visualizations' / 'individual'
        
        for viz_type, source_path in visualization_files.items():
            try:
                # Determine if it's portfolio or individual visualization
                if ('portfolio' in viz_type.lower() or 
                    'three_file_comparison' in viz_type.lower() or
                    viz_type.lower() in ['master_dashboard', 'performance_dashboard', 'risk_dashboard', 'trade_analysis', 'signal_analysis']):
                    
                    # Portfolio visualization
                    dest_path = portfolio_viz_dir / source_path.name
                    if source_path.exists():
                        shutil.copy2(source_path, dest_path)
                        organized_files[f"portfolio_{viz_type}"] = dest_path
                        self.logger.info(f"Moved portfolio visualization: {source_path.name}")
                
                else:
                    # Individual ticker visualization
                    dest_path = individual_viz_dir / source_path.name
                    if source_path.exists():
                        shutil.copy2(source_path, dest_path)
                        organized_files[f"individual_{viz_type}"] = dest_path
                        self.logger.info(f"Moved individual visualization: {source_path.name}")
                        
            except Exception as e:
                self.logger.error(f"Error organizing visualization {viz_type}: {e}")
        
        return organized_files
    
    def migrate_ticker_details(self, ticker: str, traditional_output_dir: Path):
        """
        Migrate traditional ticker details to organized structure.
        
        Args:
            ticker: Ticker symbol
            traditional_output_dir: Path to traditional output directory
        """
        ticker_dir = self.strategy_run_dir / 'tickers' / ticker
        ticker_dir.mkdir(parents=True, exist_ok=True)
        
        # Files to migrate
        files_to_migrate = [
            'metrics.json',
            'risk_report.json', 
            'bias_report.json',
            'config_snapshot.yaml'
        ]
        
        for filename in files_to_migrate:
            source_file = traditional_output_dir / filename
            if source_file.exists():
                dest_file = ticker_dir / filename
                shutil.copy2(source_file, dest_file)
                self.logger.info(f"Migrated {filename} for {ticker}")
    
    def create_executive_summary(self, date_range: str, tickers: List[str]) -> Path:
        """Create executive summary report."""
        summary_file = self.strategy_run_dir / 'reports' / 'executive_summary' / f"ExecutiveSummary_{date_range}.txt"
        
        try:
            # Load portfolio analysis
            portfolio_file = self.strategy_run_dir / 'analysis_reports' / 'portfolio' / f"Portfolio_Analysis_{date_range}.json"
            if portfolio_file.exists():
                with open(portfolio_file, 'r') as f:
                    portfolio_analysis = json.load(f)
                
                with open(summary_file, 'w', encoding='utf-8') as f:
                    f.write(f"EXECUTIVE SUMMARY - PORTFOLIO BACKTEST RESULTS\n")
                    f.write(f"=" * 60 + "\n\n")
                    f.write(f"Date Range: {date_range}\n")
                    f.write(f"Analysis Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                    
                    # Portfolio summary
                    summary = portfolio_analysis.get('portfolio_summary', {})
                    f.write(f"PORTFOLIO OVERVIEW:\n")
                    f.write(f"- Tickers analyzed: {summary.get('total_tickers', 0)}\n")
                    f.write(f"- Total data points: {summary.get('total_base_data_points', 0):,}\n")
                    f.write(f"- Strategy trades generated: {summary.get('total_strategy_trades', 0)}\n")
                    f.write(f"- Risk-approved trades: {summary.get('total_risk_approved_trades', 0)}\n")
                    f.write(f"- Portfolio approval rate: {summary.get('portfolio_approval_rate', 0):.1%}\n")
                    f.write(f"- Total transaction costs: ₹{summary.get('total_portfolio_transaction_costs', 0):,.2f}\n\n")
                    
                    # Key insights
                    cross_analysis = portfolio_analysis.get('cross_ticker_analysis', {})
                    f.write(f"KEY INSIGHTS:\n")
                    f.write(f"- Most active ticker: {cross_analysis.get('most_active_ticker', 'N/A')}\n")
                    f.write(f"- Highest approval rate: {cross_analysis.get('highest_approval_rate_ticker', 'N/A')}\n")
                    f.write(f"- Highest cost ticker: {cross_analysis.get('highest_cost_ticker', 'N/A')}\n\n")
                    
                    f.write(f"STRUCTURE: This analysis uses an optimized output structure with:\n")
                    f.write(f"- Analysis reports at top level (portfolio + individual)\n")
                    f.write(f"- Organized visualizations (portfolio vs individual)\n") 
                    f.write(f"- Streamlined data files (eliminated redundant JSONs)\n")
                    f.write(f"- Comprehensive transaction cost analysis\n")
                    f.write(f"- Individual ticker details in dedicated folders\n")
                
        except Exception as e:
            self.logger.error(f"Error creating executive summary: {e}")
        
        return summary_file
    
    # Helper methods (copied from original system)
    def _count_signals(self, base_data: pd.DataFrame) -> Dict[str, int]:
        """Count different types of signals in base data."""
        signal_counts = {}
        
        signal_columns = [
            'entry_signal_buy', 'entry_signal_sell',
            'exit_signal_buy', 'exit_signal_sell',
            'long_entry', 'long_exit', 'short_entry', 'short_exit'
        ]
        
        for col in signal_columns:
            if col in base_data.columns:
                signal_counts[col] = int(base_data[col].sum()) if pd.api.types.is_numeric_dtype(base_data[col]) else 0
        
        return signal_counts
    
    def _create_empty_trades_df(self) -> pd.DataFrame:
        """Create empty trades DataFrame with proper structure."""
        columns = [
            "Trade Type", "Entry Time", "Exit Time", "Entry Price", "Exit Price",
            "Profit (Currency)", "Profit (%)", "High During Trade", "Low During Trade",
            "High Time", "Low Time", "Trade Duration (min)", "Target (%)",
            "Drawdown (%)", "RRR", "Recovery Time (min)"
        ]
        return pd.DataFrame(columns=columns)
    
    def _analyze_signals(self, base_data: pd.DataFrame) -> Dict[str, Any]:
        """Analyze signal generation patterns."""
        if base_data.empty:
            return {}
        
        return {
            'total_data_points': len(base_data),
            'signal_counts': self._count_signals(base_data),
            'signal_frequency': {
                col: round(base_data[col].sum() / len(base_data), 4)
                for col in base_data.columns
                if 'signal' in col.lower() and pd.api.types.is_numeric_dtype(base_data[col])
            }
        }
    
    def _analyze_strategy_trades(self, strategy_trades: pd.DataFrame) -> Dict[str, Any]:
        """Analyze strategy-generated trades."""
        if strategy_trades.empty:
            return {'total_strategy_trades': 0}
        
        return {
            'total_strategy_trades': len(strategy_trades),
            'trade_types': strategy_trades.get('Trade Type', pd.Series()).value_counts().to_dict() if 'Trade Type' in strategy_trades.columns else {},
            'performance_metrics': self._analyze_trades(strategy_trades.to_dict('records'))
        }
    
    def _analyze_trades(self, trades: List[Dict]) -> Dict[str, Any]:
        """Analyze basic trade statistics."""
        if not trades:
            return {'total_trades': 0}
        
        df = pd.DataFrame(trades)
        
        analysis = {
            'total_trades': len(trades),
            'profitable_trades': len(df[df.get('Profit (%)', 0) > 0]) if 'Profit (%)' in df.columns else 0,
            'losing_trades': len(df[df.get('Profit (%)', 0) <= 0]) if 'Profit (%)' in df.columns else 0,
        }
        
        if 'Profit (%)' in df.columns:
            analysis.update({
                'avg_profit_pct': float(df['Profit (%)'].mean()),
                'max_profit_pct': float(df['Profit (%)'].max()),
                'min_profit_pct': float(df['Profit (%)'].min()),
                'win_rate': analysis['profitable_trades'] / len(trades) if len(trades) > 0 else 0
            })
        
        return analysis
    
    def _analyze_risk_impact(self, strategy_trades: pd.DataFrame, risk_trades: pd.DataFrame) -> Dict[str, Any]:
        """Analyze the impact of risk management."""
        strategy_count = len(strategy_trades)
        risk_count = len(risk_trades)
        
        return {
            'trades_generated_by_strategy': strategy_count,
            'trades_approved_by_risk': risk_count,
            'trades_rejected_by_risk': strategy_count - risk_count,
            'approval_rate': risk_count / strategy_count if strategy_count > 0 else 0,
            'rejection_rate': (strategy_count - risk_count) / strategy_count if strategy_count > 0 else 0,
            'risk_efficiency': 'High' if risk_count / strategy_count > 0.7 else 'Medium' if risk_count / strategy_count > 0.3 else 'Low'
        }
    
    def _generate_recommendations(self, base_data: pd.DataFrame, 
                                  strategy_trades: pd.DataFrame, 
                                  risk_trades: pd.DataFrame) -> List[str]:
        """Generate recommendations based on analysis."""
        recommendations = []
        
        # Signal analysis recommendations
        if not base_data.empty:
            signal_cols = [col for col in base_data.columns if 'signal' in col.lower()]
            if len(signal_cols) == 0:
                recommendations.append("Consider adding signal columns to base data for better analysis")
        
        # Strategy performance recommendations
        strategy_count = len(strategy_trades)
        risk_count = len(risk_trades)
        
        if strategy_count == 0:
            recommendations.append("No trades generated by strategy - review signal generation logic")
        elif risk_count == 0:
            recommendations.append("All trades rejected by risk management - review risk parameters")
        elif risk_count / strategy_count < 0.1:
            recommendations.append("Very low trade approval rate - consider relaxing risk parameters")
        elif risk_count / strategy_count > 0.9:
            recommendations.append("Very high trade approval rate - consider tightening risk parameters")
        
        return recommendations
